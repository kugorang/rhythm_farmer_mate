---
description: 
globs: 
alwaysApply: true
---
좋아, 모바일 우선 UI를 기반으로 하되 PC에서도 어색하지 않게 구성하고, 클라이언트 사이드만으로 구성할 것이며, 노동요나 효과음은 직접 사용할 수 있는 로컬 asset 기반으로 구현할 예정인 거지. 8시간 안에 Flutter로 구현할 수 있는 실제 작업 단계를 정리하고, 사용 가능한 오디오 소스 사이트도 함께 조사해서 알려줄게.


# 리듬농부 메이트 & 노동요 작업 챌린지 통합 개발 가이드

## 개요

경희대학교 해커톤 **“농업의 기술화”** 주제에서 착안한 아이디어로, **리듬농부 메이트**와 **노동요 작업 챌린지** 기능을 통합한 Flutter 웹앱 개발 방안을 정리합니다. 이 앱은 전통적인 **노동요**(일하면서 부르는 민요로, 피로를 잊고 작업 능률을 올리기 위한 노래)를 활용하여 사용자의 작업에 리듬과 재미를 더해줍니다. 사용자는 정해진 시간 동안 노동요 음악과 BPM 리듬에 맞춰 작업하고, **타이머**와 **진행 바**로 도전(challenge)을 완수해 나갑니다.

**개발 조건:** UI는 모바일 우선으로 디자인하되 데스크톱 웹에서도 자연스럽게 표시되도록 하고, *클라이언트 사이드*만 활용합니다 (서버나 Firebase 등 백엔드 연동 없음). 앱에 사용하는 오디오 파일은 **로컬 자산**(assets)에 포함하여 오프라인으로 재생하며, 이러한 노동요/리듬/효과음에 대한 **무료 음원 소스**도 함께 조사합니다. 총 개발 소요 시간은 약 **8시간**으로 가정합니다.

## 주요 기능 명세

통합된 웹앱에서 구현할 핵심 기능은 다음과 같습니다:

* **작업 타이머**: 사용자가 작업 세션 시간을 설정하거나, 선택한 노동요 **음악 길이에 맞춰 자동 설정**된 타이머를 제공합니다. 타이머 시작과 함께 카운트다운이 진행되고, 화면에 남은 시간이 표시됩니다. 작업 시간 종료 시 알림(UI 표시 또는 소리)으로 세션 종료를 알려줍니다.

* **BPM 리듬 시각화**: 노동요의 박자(BPM)에 맞춰 **리듬 표시기**(예: 아이콘 깜빡임 또는 애니메이션)를 제공합니다. 이는 사용자에게 일정한 작업 리듬을 제시하여 집중도를 높입니다. BPM 값은 미리 정의된 노래의 템포를 사용하거나, 사용자가 메트로놈처럼 BPM 값을 설정할 수 있습니다. 일정 간격으로 타이머 이벤트를 발생시켜 박자에 맞춰 아이콘 색상을 변경하거나 크기를 변화시키는 식으로 구현합니다 (예: BPM 120이면 0.5초마다 한 번 이벤트 실행).

* **노동요 음악 재생**: 작업 시간 동안 **로컬에 저장된 노동요 오디오 파일**을 재생합니다. 사용자는 준비된 음악 목록에서 선택하거나 기본 곡을 플레이할 수 있습니다. 오디오 플레이어는 일시정지/재생, 정지 등의 기본 제어를 제공하며, 타이머와 연동하여 **시작 버튼**을 누르면 음악과 타이머가 동시에 시작되도록 합니다. (브라우저 특성상 사용자 상호작용 없이 자동 재생되지 않으므로, 사용자의 시작 동작에 연동합니다.)

* **작업 챌린지 진행도 표시**: 현재 진행 중인 작업 챌린지의 경과를 시각화합니다. **진행 바**(Progress bar 또는 게이지)를 통해 전체 목표 대비 현재 진행 상태를 표시하여 사용자에게 동기부여를 합니다. 예를 들어 5분 중 3분 경과했다면 60% 진행으로 나타냅니다. 타이머가 줄어들거나 음악 재생 위치가 늘어남에 따라 실시간으로 진행 바가 갱신됩니다. 챌린지 완료 시 완료 표시(예: “챌린지 성공!” 다이얼로그 또는 애니메이션)를 보여줍니다.

* **모바일 우선 UI/UX**: 스마트폰 화면에서 사용하기 쉬운 단순하고 직관적인 인터페이스를 제공합니다. 큰 버튼(재생/일시정지, 시작/중지)과 명확한 글씨의 타이머 디스플레이를 배치합니다. 데스크톱 웹에서는 동일한 기능을 중앙에 배치하거나 여백을 활용하여 **어색함 없이** 표시되도록 조정합니다.

위 기능들은 모두 오프라인/클라이언트 내부에서 동작하므로, 사용자 활동이나 진행 상황은 앱이 실행되는 동안 메모리 상에 유지됩니다 (세션이 끝나면 누적 통계 등은 별도로 저장되지 않음).

## 개발 단계별 계획

약 **8시간**의 개발 시간 내에 완성하기 위해, 개발 절차를 단계별로 세분화하고 각 단계마다 예상 소요 시간과 난이도를 평가합니다.

1. **프로젝트 셋업 및 UI 뼈대 구성** (예상 소요: 1.0시간, 난이도: 하)

   * 새로운 Flutter 프로젝트를 생성하고 **웹 플랫폼**을 활성화합니다. Flutter 3+에서는 `flutter create` 시 기본적으로 웹이 지원되므로 바로 시작할 수 있습니다.
   * `pubspec.yaml`에 웹용으로도 Material/Cupertino 디자인이 적용되도록 설정을 확인하고, 앱의 기본 테마나 폰트를 필요한 경우 지정합니다.
   * **화면 레이아웃 구조를 설계**합니다: 모바일 기준으로 한 화면에 타이머 표시, 진행 바, 음악 정보 및 재생 제어 버튼 등이 들어갈 영역을 스케치합니다. Flutter의 `Scaffold`를 사용하여 기본 화면을 구성하고, 상단에는 앱 제목이나 간단한 설명 (예: “리듬농부 메이트”)을 배치할 수 있습니다.
   * 컬럼(`Column`) 위젯 등을 사용해 **세로 방향**으로 주요 UI 요소의 자리를 마련합니다. 우선은 더미 텍스트/아이콘으로 자리를 표시하고, `Container` 등에 색을 넣어 영역을 구분해봅니다. 이렇게 초기 레이아웃만 잡아두고, 기기별 반응형 동작은 나중 단계에서 조정합니다.

2. **오디오 자산 준비 및 음악 재생 기능** (예상 소요: 1.5시간, 난이도: 중)

   * 해커톤 아이디어에 맞는 **노동요 음원 파일**을 1\~2곡 선정합니다. 무료 음원 사이트 (하단 참조)에서 적절한 MP3/Ogg 파일을 다운로드하여 프로젝트의 `assets/audio` 폴더 등에 저장합니다. 예를 들어 신명나는 장단의 전통 노동요나 루프 배경음 등을 고릅니다.
   * `pubspec.yaml`에 해당 파일 경로를 등록하여 Flutter 앱에 자산으로 포함시킵니다 (e.g. `assets/audio/song1.mp3`).
   * **오디오 플레이어 패키지**를 추가합니다. Flutter에는 몇 줄의 코드만으로 구현 가능한 오디오 플레이어 패키지가 존재하므로 이를 활용합니다. 예를 들어 `just_audio` 패키지나 `audioplayers` 패키지를 사용하면 Android, iOS, 웹 등 여러 플랫폼에서 동일한 코드로 오디오를 재생할 수 있습니다.
   * 패키지 초기 설정: `pubspec.yaml`의 `dependencies`에 패키지를 추가하고 `flutter pub get`으로 설치합니다. 그런 다음 Dart 코드에서 `import` 합니다.
   * **오디오 재생 로직 구현**: 우선 간단한 재생/정지 기능부터 구현합니다. `AudioPlayer` 객체를 생성하고, 앱 시작 시 `setSource` 또는 `setAsset` 메서드로 로컬 자산 오디오를 로드합니다. 사용자가 “시작” 버튼을 누르면 `player.play()`를 호출하여 음악이 재생되도록 합니다. 일시정지/정지 버튼도 연결하여 `pause()` 또는 `stop()`을 호출하면 음악이 멈추게 구현합니다.
   * 이때 Flutter 웹에서는 **사용자 조작 이벤트** 없이 오디오가 자동재생되지 않으므로, 반드시 사용자 버튼 onPressed 핸들러 내에서 재생을 시작해야 함을 확인합니다. Chrome 등의 정책에 따라 음소거된 상태로 시작하거나, 첫 재생 시 묵음이 발생할 수 있으므로, 필요하면 시작 전에 `player.setVolume(1.0)` 등의 볼륨 세팅을 해줍니다.
   * 재생할 오디오의 \*\*길이(재생시간)\*\*를 얻고 싶다면 `just_audio`의 `durationStream`이나 `audioplayers`의 `getDuration()` 등을 활용할 수 있습니다. 우선 이 단계에서는 로그 등으로 정상적으로 재생 시작/종료가 동작하는지 확인합니다.

3. **타이머 및 상태 관리 구현** (예상 소요: 1.5시간, 난이도: 중)

   * Dart의 `Timer` 클래스를 활용하여 **카운트다운 타이머**를 구현합니다. 예를 들어 `Duration` 간격(1초 등)으로 `Timer.periodic`을 설정하면 주기적으로 콜백을 실행할 수 있습니다.
   * 앱의 **상태 관리**는 복잡도가 낮으므로 StatefulWidget과 `setState`를 사용하여 간단히 구현합니다. (필요시 `Provider` 등을 사용할 수도 있으나 8시간 내 개발에서는 overkill일 수 있습니다.) `State` 클래스에 남은 시간(`Duration remainingTime` 또는 초 단위 `int remainingSeconds`)과 진행도(`double progressPercent`) 등을 상태로 가지고, 1초마다 `remainingTime`을 감소시키고 `setState`로 UI를 업데이트합니다.
   * 타이머 시작 로직: “시작” 버튼이 눌리면, 선택된 세션 길이에 맞게 `remainingTime`을 설정하고 `Timer.periodic(1초)`을 시작합니다. 이와 동시에 2단계에서 준비한 `AudioPlayer.play()`를 호출하여 **음악과 타이머가 동기화**되어 시작하도록 합니다.
   * 매 Tick마다 (`Timer.periodic` 콜백) `remainingTime`을 1초 감소시키고, **진행도 값**을 계산합니다. 진행도는 `progressPercent = elapsedTime / totalTime` 형태로 계산하여 0.0\~1.0 사이로 관리합니다. 또한 남은 시간 `remainingTime`을 `mm:ss` 포맷의 문자열로 변환하여 화면의 타이머 Text 위젯에 표시합니다.
   * 타이머가 0에 도달하면 세션 종료 처리를 합니다. 이때 `AudioPlayer`도 `stop()`하거나 자연스럽게 곡이 끝났는지 확인합니다. 하나의 곡 길이가 세션 길이와 정확히 일치하지 않을 경우를 대비하여, **타이머 우선 종료** 시 음악도 멈추거나 페이드아웃 처리할 수 있고, 반대로 음악이 먼저 끝났다면 타이머를 해당 시점에 맞춰 종료시켜줍니다. (간단히 구현하려면 세션 시간을 음악 길이와 동일하게 설정하거나, 음악 반복재생 옵션도 고려 가능합니다.)

4. **BPM 리듬 표시 및 동기화** (예상 소요: 1.0시간, 난이도: 중)

   * 음악의 박자에 맞춰 시각 효과를 주는 기능을 구현합니다. 우선 간단히 **비주얼 메트로놈** 형태로, 화면에 작은 원형 또는 아이콘을 두고 박자마다 색상을 깜빡이거나 크기를 키웠다가 줄이는 애니메이션을 만듭니다.
   * BPM 값을 결정하는 방법: 만약 사용 중인 노동요 음원의 BPM 정보를 알고 있다면 해당 값을 하드코딩합니다 (예: 120 BPM). 정보를 모를 경우, 대표적인 빠르기로 60, 90, 120 BPM 등을 선택할 수도 있고, 사용자가 슬라이더로 BPM을 조정할 UI를 제공할 수도 있습니다 (시간상의 제약으로 고정값 사용 권장).
   * 구현 방식: BPM이 120이라면 1분에 120번, 즉 0.5초 간격으로 박자신호를 줘야 합니다. 이를 위해 별도의 `Timer.periodic(Duration(milliseconds: 500), ...)`을 사용하거나, Flutter의 `AnimationController`로 0.5초짜리 반복 애니메이션을 설정할 수 있습니다. 단순화를 위해 Timer로 접근하면, 콜백에서 `setState`로 리듬 아이콘의 상태(예: visible 여부나 색상)를 토글하면 됩니다. 이 때 오디오 재생과 정확히 맞추는 것은 어렵지만, 대략적인 박자 감지를 목표로 합니다.
   * Flutter 애니메이션: 조금 더 자연스러운 효과를 원한다면 `AnimationController(vsync: this, duration: beatDuration)` + `repeat()`로 애니메이션을 반복하고, `AnimatedBuilder`나 `AnimatedContainer` 등을 통해 아이콘의 크기 혹은 투명도를 사이클마다 변화시키는 방법도 있습니다. 박자가 시작될 때마다 아이콘의 크기를 1배에서 1.2배로 커지게 하고 다시 줄이는 식으로 구현하면 심장박동 같은 비주얼 효과를 줄 수 있습니다.
   * 오디오 BPM 동기: `just_audio`의 `positionStream` 등을 활용하면 현재 재생 위치를 알 수 있으나, 실시간 BPM 추출은 복잡하므로 현재 단계에서는 **독립적인 타이머 기반**으로 구현합니다. (추후 발전시키려면 특정 구간마다 비트 소리를 함께 재생하거나, BPM 분석 알고리즘을 적용해볼 수 있습니다.)

5. **진행 바 및 UI 마무리** (예상 소요: 1.0시간, 난이도: 하)

   * 3단계에서 계산한 `progressPercent` 값을 활용하여 **진행 바**(`LinearProgressIndicator` 등)를 동작시킵니다. `LinearProgressIndicator(value: progressPercent)` 형태로 사용하면 0.0에서 1.0까지의 값에 따라 채워진 막대가 표시됩니다. 커스텀 디자인이 필요하면 `Container`의 width를 `MediaQuery.of(context).size.width * progressPercent`로 설정하는 방식으로 직접 그릴 수도 있습니다.
   * 진행 바에는 도전 과제의 **달성률**을 직관적으로 보여주며, 필요 시 퍼센트 텍스트(예: “60%”)를 곁들이거나, 남은 시간/전체 시간 문구를 함께 표기합니다.
   * UI 요소들의 디자인을 다듬습니다. 모바일 화면을 기준으로 각 요소의 \*\*크기와 여백(padding)\*\*을 조정하여 손가락 터치가 편하도록 하고 가독성을 높입니다. 예를 들어 시작/정지 버튼은 `IconButton`이나 `FloatingActionButton`을 활용해 충분히 크게 만들고, 타이머 표시 Text는 `TextStyle`을 크게 설정합니다.
   * **상태 변화 UX**: 챌린지 시작 전/진행 중/완료 후의 UI 변화를 관리합니다. 시작 전에는 진행 바와 타이머가 0 초기상태이고, 시작 버튼 활성화. 시작하면 시작 버튼을 일시정지/중지 버튼으로 바꾸거나 비활성화하고, 진행 바와 타이머 갱신. 완료 시에는 완료 메시지와 함께 완료음을 재생하거나 (간단한 효과음 삽입 가능), 완료 애니메이션(예: 체크 마크 나타남)을 추가합니다. 그런 뒤 다시 초기 상태로 돌아가거나, 연속해서 또 다른 세션을 시작할 수 있도록 합니다.

6. **반응형 레이아웃 및 데스크톱 대응** (예상 소요: 1.0시간, 난이도: 중)

   * 모바일 우선으로 만든 UI를 **데스크톱 웹브라우저 화면에 최적화**합니다. Flutter 앱은 하나의 코드베이스로 모바일, 웹, 데스크톱 등 다양한 해상도에서 실행될 수 있으므로, 각 환경에 맞춘 **반응형 UI**가 중요합니다.
   * Flutter에서 반응형 UI를 구현하는 일반적인 방법은 **브레이크포인트**를 정해 레이아웃을 변경하거나, **Flexible/Expanded 위젯**을 사용해 화면 크기에 따라 자동으로 크기가 조절되게 만드는 것입니다. 본 앱에서는 비교적 단순한 단일 페이지 UI이므로, *유연한 레이아웃* 위주로 적용합니다.
   * 구현: 화면의 가로 폭(`MediaQuery.of(context).size.width`)을 확인하여 일정 값 이상이면 레이아웃이나 스타일을 약간 조정합니다. 예를 들어 폭이 넓은 데스크톱 화면에서는 본문 `Column`을 `Center` 위젯으로 감싸고 최대 너비를 제한하여 너무 퍼지지 않게 합니다 (예: `ConstrainedBox`로 maxWidth를 500px로 제한). 또한 좌우에 여백을 두어 중앙에 몰려있게 하면 가독성이 좋습니다.
   * **글자 크기/배치 조정**: 데스크톱에서는 더 큰 화면에 맞게 폰트 사이즈를 조금 키우거나, 혹은 반대로 너무 커보이면 줄입니다. `MediaQuery.textScaleFactor`나 `LayoutBuilder`를 활용해 화면 크기 범주별로 `ThemeData`의 textTheme을 조절할 수 있습니다.
   * 만약 태블릿이나 아주 큰 화면에서 추가 정보를 보여주고 싶다면, 예를 들어 **2단 레이아웃**(한 쪽엔 리스트/ 설정, 한 쪽엔 메인 진행 화면)도 고려할 수 있지만, 8시간 내 구현에서는 단일 컬럼 유지로도 무방합니다. 중요한 것은 다양한 크기의 기기에서도 UI 요소들이 **비율 유지**하며 배치되는 것입니다. Flutter의 `Flexible` 및 `Expanded` 위젯을 사용하면 컨테이너들이 화면 비율에 맞춰 유연하게 확장되어 해상도 변화에 자연스럽게 대응할 수 있습니다.
   * 기능 테스트: Chrome 등 데스크톱 브라우저에서 개발자 도구의 Device Mode를 사용해 **여러 디바이스 해상도**로 시뮬레이션해 보고, 레이아웃이 깨지지 않는지, 글자가 너무 작거나 크지 않은지 확인합니다. 필요하면 특정 해상도 조건 (`if width > ...`)으로 Padding을 늘리거나 FontSize를 조절하여 **모든 환경에서 어색함 없는 UI**를 완성합니다.

7. **디버깅 및 마무리** (예상 소요: 0.5시간, 난이도: 하)

   * 전체 앱 기능을 통합 테스트합니다. 타이머 시작 → 음악 재생 → BPM 표시 → 진행 바 업데이트 → 타이머 종료/음악 정지 흐름이 끊김없이 이어지는지 확인합니다.
   * 특히 **동시성 이슈**가 없는지 점검합니다. 예를 들어 타이머가 진행 중일 때 “중지”를 누르면 Timer와 오디오 모두 안전하게 취소/정지되어야 합니다. 여러 번 시작/중지해도 이중으로 Timer가 돌지 않도록 관리합니다.
   * 웹 빌드(`flutter build web`) 후 생성된 웹앱을 크롬, 파이어폭스 등에서 테스트하여 오디오가 제대로 재생되는지, 버튼 클릭 등 이벤트 응답에 문제없는지 확인합니다. (간혹 **크로스브라우저** 이슈로 Safari에서 audio context 초기화 필요 등의 이슈가 있을 수 있으나, audioplayers나 just\_audio는 대부분 대응됨).
   * 주석 및 문서를 정리하고, **README**에 사용한 무료 음원에 대한 출처와 라이선스 표시를 간단히 남깁니다. (음원 출처 표기는 사용한 음원이 CC BY 등의 라이선스일 경우 필수입니다.)

각 단계 수행에 있어 예상 시간을 넘길 경우, 우선 MVP (최소 기능 제품)를 완성하는 것을 목표로 합니다. 예를 들어 BPM 표시나 반응형 디자인은 핵심 기능 구현 후 여유 시간에 적용해도 되는 부가요소입니다. **8시간 내 완료**를 위해 우선순위를 관리하며 개발합니다.

## 모바일/데스크톱 레이아웃 전략

모바일 퍼스트로 UI를 설계하되, Flutter의 장점을 살려 하나의 코드베이스로 **다양한 화면 크기에 적응**하도록 합니다. 주요 전략은 다음과 같습니다:

* **Flexible한 위젯 사용**: Column 내의 위젯들을 고정 크기보다는 `Expanded`, `Flexible`로 감싸 필요 시 화면에 맞게 늘어날 수 있게 합니다. 예를 들어 상단 여백이나 일부 장식 이미지는 `Spacer()` 등을 사용해 화면비에 따라 자동 조절하게 하고, 진행 바도 가로폭에 100% 맞춰 늘어나도록 합니다. 이렇게 하면 해상도에 따라 UI가 자연스럽게 비율을 유지합니다.

* **LayoutBuilder & MediaQuery**: `LayoutBuilder`를 사용하여 부모 제약조건의 크기를 확인하고 breakpoint별로 다른 레이아웃을 적용합니다. 예를 들어 `constraints.maxWidth`가 600 이상이면 좌우에 padding을 늘린 Container로 감싸거나, 폰트 크기를 약간 키워줍니다. 1000 이상이면 한 화면에 더 여유가 있으니 진행 상황에 대한 텍스트 설명을 추가로 보여주는 등 **조건부 레이아웃 변화**도 가능합니다. Flutter에서는 화면 크기에 따라 1단 레이아웃에서 2단 레이아웃으로 변경하는 식의 대응도 흔히 쓰입니다. 본 프로젝트에서는 큰 화면에서 UI 배치를 중앙 정렬 및 최대너비 제한으로 변경하는 정도로 충분합니다.

* **Platform 특성 고려**: 웹/데스크톱에서는 hover 효과나 팝업 크기 등이 모바일과 다를 수 있습니다. Material 디자인의 적응형 요소 (Adaptive Widgets)를 활용하면 일부 위젯이 플랫폼에 따라 자동 스타일링됩니다. 필요하다면 `kIsWeb` 또는 `Theme.of(context).platform` 값을 확인하여 플랫폼별 UI 튜닝도 가능합니다. 다만, 8시간 프로젝트에서는 세세한 플랫폼 차이보다는 **화면 크기**에 따른 조정에 집중합니다.

* **입력 방식 차이**: 모바일 터치는 손가락, 데스크톱은 마우스 클릭이 주로 사용됩니다. 버튼 크기를 모바일 기준으로 충분히 크게 설계했다면 데스크톱에서도 문제없이 클릭할 수 있습니다. 추가로 데스크톱 사용자를 위해 키보드 단축키 (예: 스페이스바로 시작/정지) 등을 지원하면 좋지만, 필수는 아닙니다.

이러한 레이아웃 전략을 통해, 작은 스마트폰 화면부터 큰 데스크톱 모니터까지 **일관되면서도 최적화된 UX**를 제공할 수 있습니다. 실제로 Flutter는 모바일용으로 설계된 앱을 다른 플랫폼에서도 구동 가능하게 확장하기에 유용하며, 하나의 UI 구조를 가지고 약간의 조건 분기로 다양한 디바이스에 대응할 수 있습니다.

## 활용 가능한 주요 Flutter 패키지

프로젝트 구현을 위해 사용하거나 참고할 만한 Flutter 패키지 및 도구를 정리합니다. 각 패키지의 간단한 소개와 사용법 요약을 제공합니다:

* **just\_audio** – 풀featured한 오디오 플레이어 패키지입니다. 로컬 asset, URL, 파일 등 다양한 소스를 재생할 수 있고, 스트리밍, 시퀀싱, Loop 등의 기능도 갖추었습니다. `just_audio`를 사용하면 몇 줄의 코드만으로 음악 플레이어를 삽입할 수 있습니다. 사용법: `AudioPlayer player = AudioPlayer();` 생성 후 `player.setAsset('assets/audio/노래.mp3')`로 로드, 그리고 `player.play()`를 호출하면 재생됩니다. 재생 제어를 위해 `pause()`, `stop()`, `seek()` 등의 메서드와 현재 재생 위치/진행률 확인을 위한 `positionStream`, `durationStream` 등을 제공합니다.

* **audioplayers** – 경량의 대안이 되는 오디오 재생 패키지로, 하나의 API로 모바일과 웹 등 **모든 플랫폼**에서 동작합니다. 간편한 사용을 목표로 설계되어 `AudioPlayer().play(AssetSource('음원.mp3'))` 같은 단순 호출로 asset 오디오를 틀 수 있습니다. Flutter 팀 공식 지원 패키지는 아니지만 커뮤니티에서 널리 사용되며, 프로젝트에 따라 just\_audio보다 설정이 적어 빠르게 적용하기 좋습니다. 다만 기능 면에선 just\_audio가 더 세밀한 제어를 제공합니다. 본 프로젝트에서는 둘 중 익숙한 것을 사용하면 됩니다.

* **provider** – 상태 관리 패키지로, 앱의 상태(예: 타이머 값, 재생 상태 등)를 위젯 트리 하위에 효율적으로 공유할 수 있게 합니다. 작은 앱이라 **필수는 아니지만**, 규모가 커질 경우를 대비해 학습하기 좋습니다. 사용법: ChangeNotifier 모델 클래스를 정의하고 `ChangeNotifierProvider`로 제공한 뒤, 하위에서 `Provider.of<모델>(context)`로 상태를 읽거나 `Consumer<모델>`로 변화에 반응합니다. 본 앱에서는 대부분 단일 화면 내 로컬 상태이므로 StatefulWidget으로 충분하지만, 타이머와 오디오 상태를 별도 클래스 관리하고 싶다면 provider로 분리할 수 있습니다.

* **flutter\_launcher\_icons** – 앱 아이콘을 손쉽게 생성해주는 패키지입니다. 해커톤 산출물을 배포하거나 저장할 때 아이콘을 꾸미면 완성도를 높일 수 있습니다. pubspec.yaml에 아이콘 이미지를 지정해주면 Android, iOS, Web용 아이콘을 한번에 만들어줍니다. (웹의 favicon도 생성됨)

* **responsive\_framework** – Flutter 웹 개발 시 유용한 반응형 디자인 패키지입니다. 미디어쿼리처럼 여러 화면 크기에 대응하여 폰트 크기와 레이아웃을 자동으로 스케일링해줍니다. 이 패키지를 사용하면 일일이 LayoutBuilder를 쓰지 않고도 기본적인 반응형 설정을 할 수 있습니다. 다만 본 프로젝트에서는 직접 구현할 수 있을 정도로 간단하므로 꼭 필요하진 않습니다.

* **flutter\_spinkit** – 로딩 인디케이터나 스피너 애니메이션 모음 패키지입니다. 챌린지 진행 중 특별한 애니메이션을 넣고 싶거나, BPM 리듬 표시 대신 멋진 효과를 주고 싶을 때 활용 가능합니다. 여러 가지 형태의 뛰는 심장, 맥박 등 애니메이션 위젯을 제공하므로, 적절한 것을 골라 BPM 주기마다 `restart()`하거나 제어하면 재사용할 수 있습니다.

이 외에도 Flutter에는 **수많은 공개 패키지**들이 있습니다. 해커톤 기간에는 새로운 패키지를 적용하면 시간 소모가 크므로, 위에 열거한 핵심 위주로 사용하고 복잡한 기능은 지양합니다. 공식 문서와 패키지의 Readme 예제를 참고하면 짧은 시간 안에 적용 가능하며, pub.dev의 패키지 페이지에 명시된 간단 예제를 그대로 따라해 보는 것이 좋습니다.

## 무료 음원 소스 목록

앱에서 사용할 노동요, 배경 리듬, 효과음을 얻을 수 있는 **무료 음원 사이트**들을 정리합니다. 이 사이트들은 저작권 문제가 없거나 Creative Commons 라이선스로 배포되는 음원을 제공합니다 (일부는 출처 표기 조건이 있을 수 있음).

* **Free Music Archive (FMA)**: 수많은 장르의 음악을 무료로 제공하는 유명 아카이브입니다. 대중음악부터 인디음악까지 다양하며, 다운로드 전에 미리 듣기가 가능합니다. CC 라이선스 별 필터링도 지원하여 상업적으로도 사용 가능한 노동요풍 음악을 찾을 수 있습니다.

* **Jamendo**: 전 세계 인디 음악가들의 곡을 공유하는 플랫폼입니다. 약 24만 곡 이상의 음악이 있고 대부분 Creative Commons로 제공됩니다. 노동요 테마에 맞는 신나는 분위기의 곡이나 잔잔한 배경음 등을 검색해볼 수 있습니다. 다만 곡에 따라서는 비영리 용도로만 무료인 경우가 있으므로 라이선스 확인 필요.

* **YouTube Audio Library**: 유튜브 크리에이터를 위해 제공되는 무료 음원 라이브러리입니다. 사용 용도에 상관없이 무료로 쓸 수 있는 배경음악(BGM)과 효과음들이 모여 있습니다. 한국의 전통적인 분위기의 곡은 많지 않지만, 작업 리듬에 맞는 다양한 장르의 음악을 찾기 좋습니다. (유튜브 스튜디오 내에서 접근 가능)

* **ccMixter**: 뮤지션들이 보컬 샘플과 곡 샘플을 올리고 DJ들이 이를 리믹스하는 **크리에이티브 커먼즈 음악 플랫폼**입니다. dig.ccMixter 사이트에서 장르, 분위기 태그로 검색하면 수만 개의 무료 음원을 찾을 수 있고, 노동요 느낌의 반복적인 리듬 트랙이나 흥겨운 포크/일렉트로닉 곡도 발견할 수 있습니다. 다운로드 후 출처를 표시하면 자유롭게 사용할 수 있는 곡이 많습니다.

* **Incompetech**: Kevin MacLeod라는 음악가가 운영하는 무료 음원 사이트로, 영화/영상 BGM으로 유명한 곡들이 다수 있습니다. 카테고리 중에 “Work”, “Humor” 등의 분위기도 있어서 상황에 맞는 BGM을 구하기 좋습니다. 사이트에서 바로 MP3를 받고 크레딧 표시 조건으로 무료 이용 가능합니다.

* **공유마당 (KOGL)**: 한국저작권위원회가 운영하는 공공저작물 공유 사이트입니다. 전통 음악, 국악, 효과음 등을 다수 공개하고 있으며 특히 전국 각지의 **민요/노동요 음원** 84건이 지역별 대표 노동요로 공개되어 있습니다. 예를 들어 화순 길쌈놀이 노래, 고성 어로요(어부 노래) 등 실제 전통 노동요를 감상하고 다운로드할 수 있습니다. 한국 전통 농업 노동요를 사용하고 싶다면 최고의 출처입니다(공공누리 1유형으로 자유이용 가능). 국악 뿐 아니라 현대 창작 국악, 분위기별 배경음도 있으므로 활용 범위가 넓습니다.

* **Freesound**: 작업 효과음이나 버튼 소리 등 \*\*효과음(SFX)\*\*이 필요하다면 Freesound.org를 활용할 수 있습니다. 사용자들이 업로드한 방대한 소리 데이터베이스로, “farm”, “bell”, “whistle” 등 키워드로 검색하면 워크송 시작/종료를 알리는 벨소리나 메트로놈tick 소리 등도 찾을 수 있습니다. 대부분 CC0 또는 CC-BY 라이선스입니다.

* **Pixabay 음악**: Pixabay는 이미지로 유명하지만 **음악/사운드**도 제공하는 무료 플랫폼입니다. 장르나 분위기로 필터링해서 무료 음원을 다운로드할 수 있으며, 상업적 이용도 자유롭습니다. 비교적 최신 트렌드 음악이나 loop 배경음이 많아 현대적인 “노동요”(일할 때 듣기 좋은 신나는 곡) 플레이리스트를 꾸리기 좋습니다.

이 외에도 **Bensound**, **AudioNautix**, **SoundCloud(크리에이티브 커먼즈 필터)**, **ccTrax** 등의 사이트가 있습니다. 각 사이트마다 사용 조건이 약간씩 다르니, 다운로드한 음원의 라이선스 종류(CC BY, CC BY-NC 등)를 확인해야 합니다. 해커톤 데모 단계에서는 크레딧 표기가 필수는 아니지만, 추후 공개시를 대비해 출처를 기록해두는 것이 좋습니다.

以上와 같이, Flutter 기술 스택을 활용하여 8시간 내에 **리듬농부 메이트 + 노동요 챌린지** 웹앱을 구현하는 방안을 정리했습니다. 이 가이드는 Cursor Editor에서 규칙 기반 설계 문서로 활용할 수 있도록 논리적인 단계와 근거를 제시하고 있습니다. 실제 개발 시에는 상황에 맞게 유연하게 조정하되, 핵심 아이디어인 “기술로 전통 농업 문화(노동요)를 현대 작업에 접목”하는 목표를 유지하며 진행하면 성공적인 결과물을 얻을 수 있을 것입니다.

